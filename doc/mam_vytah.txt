********************************* Počítačové zpracování obrazu *********************************
Tomáš "Jethro" PokornýAbstrakt
========￼	Projekt Počítačové zpracování obrazu si klade za cíl pomocí kamery a projektoru připojeného k  počítači umožnit uživateli, aby laserového ukazovátka mohl používat jako ukazatele na objekty zobrazené na  projektoru. Aplikace zpracovávající obraz a transformující souřadnice je napsána v Objective C.  Pro vykreslování obrazu je použit Python a Python Image Library. Funkce aplikace jsou tyto: kalibrace webkamery pro dané umístění, zachycení a načtení obrazu z webkamery, analýza a hledání nasvíceného bodu, transformace snímaného obrazu pomocí transformační funkce a kalibračních dat a finální vykreslení nasvíceného bodu na projektoru. Rozpracováno je rychlejší transformace a zobrazení obrazu a v budoucnu jsou plánovány aplikace a hry tento software využívající.￼￼Začátky
=======

M&M
---	Na soustředku Krásnu to bylo téma naší konfery. Zde jsme dostali již předpřipravenou část softwaru pro snímání obrazu a pro promítání výsledků a dále jsme se zabývali zpracováním tohoto obrazu a jeho správným vykreslováním. Zde vznikly všechny dosud používané transformace a velká většina Pythonovského kódu. 
Původní cíle
------------	Původně jsme mysleli, že zpracování půjde snadno a že se za chvíli dostaneme k detekci pohybu a vykreslování čáry, ale ukázalo se, že transformace není vůbec jednoduchá  a tak jsme u ní prakticky skončili, částečně vlivem její obtížnosti, částečně vlivem začátečnické chyby.
 Programové vybavení
-------------------	Na M&M jsme pracovali na Linuxovém notebooku, ke kterému byla připojena webkamera a projektor, snímání probíhalo pomocí MPlayeru, ke zpracování sloužil Python s PIL a Tk pro zobrazování výsledků.	Nynější vybavení je notebook s Mac OS X vybavený integrovanou webkamerou iSight, připojovaný k projektoru. Snímání je realizováno pomocí frameworku CocoaSequenceGrabber v programu HledaniBodu. Tento program je napsán v Objective C a v něm rovněž probíhá hledání nejsvětlejšího bodu a transformace jeho souřadnic. Ty jsou dále předávány Pythonu k zobrazování přes Tk. Postupně probíhá přechod plně do Objective C. 
První kroky
-----------	Ze začátku jsme se učili pracovat s Pythonem, protože jsme ho nikdo pořádně neuměli, a poté jsme přistoupili k vlastnímu zpracování obrazu. Zjišťovali jsme, jak obrázek vypadá, co se v něm všechno dá najít, jak je charakteristický nasvícený bod a zkoušeli jsme ho hledat. Poté přišla na řadu transformace obrazu z kamery, na které jsme strávili dlouhý čas. Vzniklo několik konkurenčních algoritmů, avšak žádný nefungoval nijak zvlášť přesvědčivě. Nakonec se nám podařilo zprovoznit dvě transformace s relativně dobrými výsledky a úspěšně zprovoznit vykreslování.￼Teorie￼======
Snímání a zpracování obrazu---------------------------	Obraz je snímán pomocí frameworku CocoaSequenceGrabber v programu HledaniBodu. Program snímá obrázky tak, jak jsou poskytovány kamerou a na vyžádání Pythonu v nich hledá nejsvětlejší bod a říká mu jeho souřadnice. Hledání probíhá tak, že je obrázek převeden na pole bytů a nad ním se vždy počítá součet 5x5 pixelů po jednotlivých barevných složkách. Před tímto výpočtem můžou být nastaveny omezující podmínky, kdy je zbytečné výpočet provádět, protože jsou body příliš tmavé než aby na ně bylo svíceno. 	Z jednotlivých blokových součtů je zjištěno maximum hodnoty součtu hledané barevné složky a definitivně je vybrán ten bod, který má tento součet nejvyšší. U tohoto maxima jsou ještě kontrolovány součty jednotlivých složek, aby se omezily artefakty kdy pokud na projektor nesvítím se nezachytávaly zobrazené křížky. 	Tato metoda se ukázala být velmi spolehlivá, ale je potřeba najít vhodné nastavení konstant pro zahazování bodů, protože obzvláště při denním osvětlení či osvětlení různými zdroji světla  jsou snímané body různých barev a je potřeba co nejvíce špatných zahodit, ale nezahodit s nimi i ty, co chceme najít.
Kalibrace
---------	Kalibrace je prvním z dějů souvisejících s transformací. Cílem kalibrace je zjistit, v jakých bodech na snímaném obraze se zobrazují rohy obrazu zobrazovaného dataprojektorem. To je důležité proto, abychom dokázali přepočítat bod nalezený na obrazu webkamery na bod, který zobrazíme na projektoru. Nyní k funkci kalibrace. Program postupně rozsvítí 4 čtverečky v rozích obrazu projektoru a vždy chvíli počká, aby se kamera přizpůsobila, pak je sejme již popsaným způsobem a najde je. Tímto získáváme 4 kalibrační body, se kterými již můžeme počítat v transformacích.
Transformace
------------	Toto je nejdůležitější a matematicky nejobtížnější část celého projektu, která zajišťuje správné zobrazení bodu na projektoru. Co to je a proč je potřeba?Předpokládejme, že máme projektor, který promítá na plátno obdélníkový obraz. Pokud by ho promítal zkreslený, má své vlastní funkce ke korekci tohoto zkreslení. Pokud nyní obraz snímáme kamerou, získáme nějaký útvar. Optimální situace nastává, pokud kamera snímá ze stejného bodu, jako promítá projektor. V tom případě je snímaný útvar obdélník se stejným poměrem stran k promítanému obrazu. Tady nám stačí úplně základní transformace a to jednoduché přinásobení konstantou odpovídající poměru délky strany snímaného a promítaného obrazu. Toto je ale situace, která nastane velmi zřídka. Většinou snímáme kamerou obraz zkreslený, protože pokud si představíme to, co snímá kamera, jde o jakýsi nekonečně vysoký čtyřboký jehlan. 
	Pokud snímáme útvar mimo osu projektoru, bude snímaný útvar určitým řezem daného jehlanu, tudíž to bude docela obecný čtyřúhelník. My potřebujeme tento čtyřúhelník roztáhnout vhodně tak, abychom získali obdélník, který bude odpovídat obdélníku promítanému projektorem, abychom mohli tento obdélník zobrazit. To je právě záležitost transformace
Poměrová transformace
---------------------
/* !!!Tuto část prosím nahraďte popisem poměrové transformace, ideálně i se vzorečky a obrázky!!!	Toto je nejlepší námi naprogramovaná transformace. Základem je fakt, že i ve zkresleném útvaru zůstanou zachovány poměry vzdáleností a to speciálně poměrů vzdáleností nalezeného osvíceného bodu od stran. Pokud tuto úvahu zobecníme na dva rozměry, získáme rovnice, pomocí kterých můžeme získané souřadnice nalezeného bodu přepočíst na souřadnice bodu na obrazovce.*/
Grafická transformace
---------------------	Tato transformace dává nejlepší výsledky. Je postavena na funkci z knihovny PIL, která umí převést zadaný čtyřúhelník na obdélník. To je přesně to, co potřebujeme, ovšem má to jednu poměrně zásadní nevýhodu. Protože je to funkce z grafické knihovny, znamená to, že tuto transformaci umí provést pouze s obrázkem, nikoli jen daty. Je tedy potřeba vytvořit obrázek, zakreslit do něj nalezený bod, obrázek transformovat a opět transformovaný bod nalézt. To jsou hlavní 2 důvody, proč je transformace pomalá, což je její hlavní nevýhoda. Musí provést transformaci bitmapy, tzn. přepočítat každý pixel a pak my ji ještě musíme projít, abychom transformovaný pixel nalezli. Rovněž je to transformace závislá na Pythonu, tudíž při přepsání transformace do Objective c musela být vypuštěna.
Další transformace
------------------	Během vývoje vznikly ještě 2 další transformace a to transformace přibližná, která vždy předpokládala, že útvar je lichoběžník a to postupně v obou rozměrech a výsledek pak zprůměrovala. Toto byla nejúspěšnější transformace z námi naprogramovaných, než jsme přišli na chybu v transformaci poměrové a nebo než jsme zvětšili úhel mezi osou promítaného obrazu a kamerou. 	Druhá ze vzniklých transformací byla založena na úhlech a postupném posouvání kalibračních bodů do vrcholů promítaného čtyřúhelníka. Při nasimulování její činnosti ale bylo zjištěno, že byly úvahy chybné a tato transformace nemůže fungovat.ZobrazeníPoté, co je nalezen bod, který se má vykreslit na projektoru, ho již stačí jenom vykreslit. Obraz se vykresluje do černého okna o velikosti obrazu promítaného projektorem. Tato část nepotřebuje nijaké zvláštní komentáře, jediné, na co je třeba si dávat pozor, je, abychom křížek v místě vykreslovaného bodu vykreslovali správnou barvou, kterou nevyhodnotí program jak nasvětlený bod ukazovátkem.￼Aktuální stav
=============￼Aktuálně fungující
------------------	Aktuálně funguje zachytávání obrazu pomoci CocoaSequenceGrabberu, jeho zpracování a transformace souřadnic v Objective C, v Pythonu je napsáno vykreslování, které používá okno využívající Tk z původního projektu.
Rozpracované
------------	Aktuálně čeká na otestování transformace v Objecitve C. Poté se budu snažit ji zpřesnit a popřípadě zrychlit. Také snad přejdu na plné rozlišení kamery a projektoru pro přesnější zobrazování.
Problémy
-------	Prvním, zásadním a nejhloupějším problémem byl problém s poměrovou transformací. Jeho podstata byla v odlišném číslování rohů obdélníka při kalibraci a při transformaci. Tato chyba nás zdržela o jedno odpoledne, kdy jsme mohli pokračovat v programování. Byla odhalena až asi v polovině prezentace konfery na soustředění M&M. 	Problémy byly také při přepisování do Objective C, ale byly úspěšně překonány.￼Budoucnost
==========￼Přepsání do Objective-C
-----------------------Nejdůležitějším cílem do budoucnosti je dokončit přechod na Objective C, což je jeden pilíř, který by měl urychlit zpracování a zrychlit transformaci obrazu, aby byla rychlá v 320x240 a použitelná v rozlišení VGA. Tím by se  stalo zpracování použitelné pro další aplikace, vyžadující rychlejší odezvu.
Možné aplikace
--------------:Kreslení:Místo toho, aby se zobrazoval jen křížek pod nasvíceným bodem bude laser za sebou zanechávat barevnou stopu. Tímto způsobem bude možné kreslit jednoduché obrázky a může být i možnost změny barvy. Opět je ale potřeba, aby barva čáry kreslené laserem nebyla stejná jako nasvícený bod, aby nebyla chybně zachycena jeho poloha.
:Střílení balonků:Jednoduchá hra pro 1, v budoucnosti 2 hráče s různě barevnými laserovými ukazovátky, kteří budou pomocí svícení na balonky zobrazené na projektoru na tyto balonky střílet a získávat za ně body.
:Ovládání myši:Pomocí laserového ukazovátka bude možné ovládat kursor myši. Zde je problém s barvou oken, která musí být diametrálně odlišná od barvy ukazovátka, aby nedocházelo k chybným detekcím. Rovněž by bylo potřeba detekovat kliknutí, například pomocí bliknutí laserem.￼Odkazy a zdroje￼===============
Seminář M&M: http://mam.mff.cuni.cz/Referenční příručka Python Image LibraryMac OS X Reference LibraryZdrojové kódy programu a jeho stránky: http://code.google.com/p/zpracovaniobrazu/Blog se zprávami z aktuálního postupu: http://zpracovaniobrazu.blogspot.com/￼Poděkování￼==========
Tomáši Gavenčakovi za vedení konfery na M&MKarlu Královi a Lukáši Langerovi za vymyšlení poměrové transformacePetrovi za spolupráci na konfeřeMgr. Marku Blahovi za technické zázemí a podporu při pokračování projektuA všem dalším, kteří mě svými radami nasměrovali na správnou cestu￼